# 基础
1. qt的信号和槽机制
2. 信号和槽的书写
3. 对象树
4. explicit构造函数


***

### 信号和槽机制
* 信号和槽机制是Qt的核心特征，也是Qt不同于其他开发框架的最突出的特征。
* 因为在实际的开发过程中，我们开发者会希望任何对象都可以和其他对象进行通信。而Qt中就使用了信号和槽机制来进行对象间的通信。
* 信号和槽机制：当`某一件事情`发生时，可以发射一个信号，槽是一个函数，它在捕获信号之后被调用，用来响应这个信号【信号和槽机制类似于`观察者模式`】
   * 槽函数：和普通C++成员函数几乎没有区别，可以是虚函数，可以被重载，可以public,private,protected，也可以被其他C++成员函数调用
   * 唯一的区别就是 `槽可以与信号连接在一起`，定义的时候是public slots / private slots / protected slots
>例如：在用户登陆中，点击了一个按钮，按钮发出了clicked)信号【clicked信号表示按钮被按下了】，然后窗口捕获这个信号之后，通过某个槽函数【例如是on_OpenButton_clicked()】，对按钮按下进行处理【检测用户名、密码是否合法，是否输入正确等等】



* 在GUI编程中，当改变了一个部件时，希望其他的部件也能了解到变化。为了实现对象间的通信，一些工具包中使用了回调函数机制来解决。
* `回调`：指向函数的指针，把指针传递给一个要被处理的函数，那么就可以在这个函数被处理的时候在适当的地方调用这个回调函数【回调类似于`模板模式`】
>例如：你到一个商店买东西，但是刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，你接到电话后就到店里去取了货。
电话号码就是回调函数，把电话留给店员叫登记回调函数，店里后来有货了叫触发了回调事件，店员给你打电话叫做调用回调函数，你到店里取货叫响应回调事件

[题外话]类与类之间的通信方式：
1. Qt的信号与槽
2. 观察者模式
3. Boost信号槽

***

### 信号和槽的书写
* 连接信号与槽：connect(信号的发送者, 发送的是什么信号, 信号的接收者, 响应信号的槽函数, 连接的类型`不常用`);
* 信号与槽要求信号和槽的参数类型一致
```
[static] QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)

```
1. connect(button, &QPushtButton::clicked, this, &QApplication::quit);
2. connect(button, SIGNAL(clicked()), this, SLOT(quit()));

####### 第五个参数，连接的类型：
【连接的类型】这个枚举描述了在信号和槽之间的连接类型。特定的，它决定了是否一个特定信号被输送到槽函数立即，还是在随后排队输送。

1. 【默认连接】Qt::AutoConnection：`默认`
* （默认）如果接收者生存于发送这个信号的线程【发送者与接收者在同一线程】，使用Qt::DirectConnection。否则，使用Qt::QueuedConnection。连接类型在信号发射的时候决定。

2. 【直接连接】Qt::DirectConnection：
* 槽函数立即被调用当这个信号发出的时候。槽函数在发送信号的线程中执行。
* 接收到信号之后马上执行槽函数，没有任何等待

3. 【队列连接】Qt::QueuedConnection：
* 槽函数被调用当控制权返回到接收者线程的事件循环。槽函数在接受者的线程中执行。
* 使用队列连接（Qt::QueuedConnection）时，参数必须是Qt元对象系统的类型，因为Qt需要拷贝这些参数，并且把他们保存在后台事件中。如果你尝试用队列连接（Qt::QueuedConnection），并且获得了错误信息：QObject::connect: Cannot queue arguments of type 'MyType'。
调用qRegisterMetaType()函数去注册这个数据类型在建立这个连接之前。
* 执行有先后顺序，但是在不同线程间传递消息的时候，发送者发送信号之后继续做自己的事情，不会阻塞

4. 【阻塞队列连接】Qt::BlockingQueuedConnection：
* 与Qt::QueuedConnection相同，除了发送信号的线程阻塞，直到槽函数返回。这种连接类型不能用于接收者生存于发送者线程，否则将造成死锁。
* 不同线程间传递消息的时候，发送者发送了信号之后会阻塞，直到接收者的槽函数响应了事件

5. Qt::UniqueConnection：
* 这个标志可以和以上任意连接类型组合，用按位或（|）。当设置了Qt::UniqueConnection，如果这个连接已经存在，那么QObject::connect()函数将失败（也就是说：相同的信号已经连接到相同的槽函数，而且是相同的一对对象）。

***

### 对象树

对象树：能够自动、有效的组织和管理继承自QObject的Qt对象，`简化了内存回收机制`
* Qt对象树在用户界面编程上是非常有用的。它能够帮助程序员减轻内存泄露的压力。`不用一个个释放控件`
* 在创建QObject对象时，可以提供一个父对象。当创建这个对象时会自动添加它到父对象的children列表。`父对象析构时，列表中的所有对象也会被析构`
>例子：当项目创建了一个具有父窗口的对象时，该对象将被加入父窗口部件的孩子列表，当程序释放父窗口的时候，孩子列表的对象也会被逐一释放。


***

### explicit构造函数
explicit构造函数：用来防止隐式转换

```
class Test1
{
public:
  Test1(int n)
  {
      num=n;
  }//普通构造函数
private:
  int num;
};
class Test2
{
public:
  explicit Test2(int n)
  {
      num=n;
  }//explicit(显式)构造函数
private:
  int num;
};
int main()
{
  Test1 t1=12;//隐式调用其默认拷贝构造函数,成功
  Test2 t2=12;//编译错误,不能隐式调用其构造函数
  Test2 t2(12);//显式调用成功
  return 0;
```

***

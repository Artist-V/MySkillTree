## select、poll、epoll

以老师给学生回答做例子：

### 循环服务器模型：服务器再同一时刻只能响应一个客户端的请求

> 例子：当一个学生来上课，老师一直跟着这名学生，直到它解决问题离开教室，老师才能一直解决下一个学生的问题。只要有学生进入教室，无论这名学生有没有问题，老师都不能帮助其他同学解决问题，需要等到这名学生离开教室为止

* 优点：简单易懂，没有同步、加锁等复杂情况，也没有进程创建等开销　　

  * UDP循环服务器：每次从套接字上读取一个客户端请求->处理->然后将结果返回给客户端
　　　　　　　　　因为UDP是短连接，没有一个客户端可以一直占用服务端（文件传输除外），服务器可以满足每一个客户端的请求

  * TCP循环服务器：一次只能处理一个客户端的请求，完成这个客户端的所有请求后才可以断开连接，如果任务没有完成，那么它会一直占用服务器的进程，直到处理完毕之后服务器关闭连接。
　　

### 并发服务器模型：每一个客户端的请求并不是由服务器直接处理，而且由服务器的子进程/线程来处理，这样服务器可以在同一个时刻响应多个客户端的请求

　>例子：学校为了解决老师无法同时帮助多个学生解决问题，为每一个学生安排了一名老师进行辅导，但是学校的资源有限，当学生的数量达到一定量时，学校无法承担那么大的开销。

* 缺点：
  * 没有从根本上解决循环服务器处理效率低的问题（学校不能无限制的聘请无数个老师）
  * 没有解决资源利用率低的问题（每位学生不可能一直有问题，但是每个学生都占用了一名老师资源）

* 多进程并发服务器模型：改进了TCP循环服务器客户端独占服务器的情况，但是创建多个进程非常消耗资源，系统的进程数也有限制
* 多线程并发服务器模型：改进了多进程并发服务器资源消耗大的问题，但是同时也带来了同步问题，线程不健壮的问题，容易导致整个服务器的崩溃，一个进程能创建的线程数也存在上限
　　

### I/O多路复用模型：内核一旦发现进程指定的一个或者多个IO条件准备读取时，它就通知该进程。

>例子：由于资源利用率的问题，学校只聘请一名特别资深的教授（具有高端配置的服务器），这名教授处理问题的速度特别快同时安排一名班长监听每个学生有没有问题，如果有问题，班长就告诉教授，教授就快速的解决这名学生的问题，解决之后进入等待，直到监听到下一名学生出现问题为止。这样，每个学生的问题都能被即时响应和解决，而且没有浪费资源

* 优点：系统开销小，不必创建和维护进程/线程，从而大大减小了系统的开销，同时解决了线程阻塞的问题（也可以使用到并发服务器的设计中）

>【因为socket套接字也是一种文件，socket句柄就是一个文件描述符，所以可以通过数据结构存储这些文件描述符，实现通信的需求】

1. select：本质是数组【轮询 + 遍历】
  * 优点：跨平台支持性好，几乎在所有平台上都支持
  * 缺点：
    * 延展性差：用数fd_set来管理文件描述符，fd_set的本质是数组，所以select监听的个数有最大值【默认1024】
    * 数据开销大：每次调用select，都需要把fd_set从用户态拷贝到内核态，影响系统效能

2. poll：本质是链表【轮询 + 遍历】
  * 优点：解决了select监听个数受限的问题
  * 缺点：
    * 需要做从用户态到内核态的转换，和数据拷贝，效率低，然后轮询每个fd的状态，会经历多次无谓的遍历
    * 没有解决select中的性能问题，需要轮询pollfd来获取就绪的文件描述符，但是同一时刻可能只有少数的客户端有请求

###  epoll：本质是红黑树
  * 优点：不需要做用户区到内核去的转换，数据在共享内存中，epoll维护的红黑树在共享内存中，内核区和用户区共同操作共享内存

　　　
### 三种多路复用IO的区别？
1. select内部用数组实现，poll用链表实现，epoll用红黑树来实现

2. select有最大监听个数的限制，poll和epoll没有

3. 内核区用户区
  * select和poll需要做从内核区到用户区的转换，数据拷贝，效率低
  * epoll不需要，epoll维护的树及其数据都在共享内存中

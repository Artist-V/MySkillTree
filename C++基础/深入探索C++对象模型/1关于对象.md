## 关于对象
1. 加上封装后的布局成本
2. C++对象模式
3. 表格驱动对象模型
4. C++对象模型

***

###### 加上封装后的布局成本
*C++在布局以及存取时间上主要的额外负担是由virtual引起的*
* virtual function（虚函数）机制：用以支持一个有效率的“执行期绑定”
* virtual base class（虚继承）机制：用以实现“多次出现在继承体系中的base class”，有一个单一而被共享的实例
  * 多重继承下的额外负担：发生在“一个derived class和第二或后继之base class的转换”之间


###### C++对象模式
* 成员变量：static数据成员和nonstatic数据成员
* 成员函数：static函数，nonstatic函数，virtual函数
*成员本身不放在对象之中，只有“指向成员的指针”（this）才放在对象内：用以避免，成员有不同的类型，因而需要不同的存储空间导致的问题*


###### 表格驱动对象模型
*把所有与成员相关的信息抽出来，放在一个数据成员表和一个成员函数表中，对象本身内含指向这两个表格的指针*


###### C++对象模型
*空间和存取时间的效率*
*如果应用程序代码本身未曾改变，但所用到的对象和非静态数据成员有所修改（增加、移除、修改），那么这些应用程序代码同样需要重新编译*
* 类模型：非静态成员
* 类外模型：静态成员
* 虚函数：
  * 每一个类产生一堆指向虚函数的指针，放在表格中，这个表格被成为virtual table（vtbl）
  * 每一个对象被安插一个vptr指针指向相关的vtbl，vptr的set和reset都由每一个类中的构造函数、析构函数和拷贝赋值运算符
